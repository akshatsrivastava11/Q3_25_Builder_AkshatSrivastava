use anchor_lang::prelude::*;
use anchor_spl::{associated_token::AssociatedToken, metadata::{self, mpl_token_metadata::instructions::{FreezeDelegatedAccountCpi, FreezeDelegatedAccountCpiAccounts}, MasterEditionAccount, Metadata, MetadataAccount}, token::{approve, Approve, Mint, TokenAccount}, token_2022::spl_token_2022::extension::confidential_transfer::instruction::ciphertext_ciphertext_equality};

use crate::{StakeAccount, StakeConfig, UserConfig};

#[derive(Accounts)]
pub struct Stake<'info>{
    #[account(mut)]
    pub user:Signer<'info>,
    pub mint:Account<'info,Mint>,
    pub collection_mint:Account<'info,Mint>,
    #[account(
        mut,
        associated_token::mint=mint,
        associated_token::authority=user
    )]
    pub ata_mint:Account<'info,TokenAccount>,
    #[account(
        seeds=[b"metadata",metadata_program.key().as_ref(),mint.key().as_ref()],
        bump,
        seeds::program=metadata_program.key(),
        constraint=metadata.collection.as_ref().unwrap().key().as_ref()==collection_mint.key().as_ref(),
        constraint=metadata.collection.as_ref().unwrap().verified==true
    )]
    pub metadata:Account<'info,MetadataAccount>,
    #[account(
        seeds=[b"metadata",metadata_program.key().as_ref(),mint.key().as_ref(),b"edition"],
        bump,
        seeds::program=metadata_program.key()
    )]
    pub master_edition:Account<'info,MasterEditionAccount>,
    #[account(
        init,
        payer=user,
        space=8+StakeAccount::INIT_SPACE,
        seeds=[b"stake",stake_config.key().as_ref(),mint.key().as_ref()],
        bump
    )]
    pub stake_account:Account<'info,StakeAccount>,
    #[account(
        seeds=[b"config"],
        bump
    )]
    pub stake_config:Account<'info,StakeConfig>,
    #[account(
        mut,
        seeds=[b"user",user.key().as_ref()],
        bump
    )]
    pub user_config:Account<'info,UserConfig>,
    pub system_program:Program<'info,System>,
    pub token_program:Program<'info,Token>,
    pub associated_token_program:Program<'info,AssociatedToken>,
    pub metadata_program:Program<'info,Metadata>
}

impl<'info>Stake<'info>{
    pub fn Stake(&mut self,bumps:StakeBumps)->Result<()>{
        let cpi_program=self.token_program.to_account_info();
        let accounts=Approve{
            authority:self.user.to_account_info(),
            delegate:self.stake_account.to_account_info(),
            to:self.ata_mint.to_account_info()
        };

        let ctx=CpiContext::new(cpi_program, accounts);
        approve(ctx, 1)?;    
        let delegate=&self.stake_account.to_account_info();
        let token_account=&self.mint.to_account_info();
        let edition=&self.master_edition.to_account_info();
        let mint=&self.mint.to_account_info();
        let metadata=&self.metadata.to_account_info();
        let seeds=&[
            b"state",
            self.user_config.key().as_ref(),
            self.mint.key().as_ref(),
            &[self.stake_account.bump]
        ];
        let signers=&[&seeds[..]];
        FreezeDelegatedAccountCpi::new(
            metadata,
            FreezeDelegatedAccountCpiAccounts{
                delegate,
                edition,
                mint,
                token_account,
                token_program
            }
        ).invoke_signed(signers_seeds)?;
        self.stake_account.set_inner(StakeAccount {
             mint: self.mint.key(),
              owner: self.mint.key(),
               staked_at:Clock::get()?.unix_timestamp,
                bump: bumps.stake_account
             });        
             Ok(())
        // todo!()
    }
}